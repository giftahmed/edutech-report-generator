import os
import subprocess
import platform
import pandas as pd
from tkinter import Tk, filedialog, Button, Label, messagebox, ttk, simpledialog, Toplevel, Entry
from tkinter import colorchooser
from fpdf import FPDF
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from groq import Groq
from typing import List

# =======================
# Configuration & Constants
# =======================
DEFAULT_HEADER = "ABC Academy - Report Card"
DEFAULT_FOOTER = "Generated by EduAnalytics Pro | Confidential Student Report"
DEFAULT_THEME_COLOR = "#000000"  # Black

# Groq AI Configuration
os.environ["GROQ_API_KEY"] = "your-api-key"
groq_client = Groq(api_key=os.getenv("GROQ_API_KEY"))

def hex_to_rgb(hex_color):
    """Convert a hex color (e.g., '#ff0000') to an RGB tuple."""
    hex_color = hex_color.lstrip('#')
    return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))

# =======================
# Core Functions
# =======================
def calculate_grade(score: float) -> str:
    """Calculate letter grade based on numerical score using the following scale:
       A: 90 and above, B: 80-89, C: 70-79, D: 60-69, E: 40-59, F: below 40
    """
    return next(
        (grade for threshold, grade in [
            (90, "A"), (80, "B"), (70, "C"), (60, "D"), (40, "E")
        ] if score >= threshold),
        "F"
    )

def validate_dataframe(df: pd.DataFrame) -> bool:
    """Validate that required columns (Name and ID) and at least one subject (with FA1, FA2, Exam) exist."""
    required_columns = {'Name', 'ID'}
    existing_columns = set(df.columns)
    
    has_valid_subjects = any(
        all(f"{subject} {assessment}" in existing_columns
            for assessment in ["FA1", "FA2", "Exam"])
        for subject in {col.split()[0] for col in existing_columns}
    )
    
    return required_columns.issubset(existing_columns) and has_valid_subjects

def generate_summary(student_record):
    """
    Generate a concise summary and remark for a student's record using the Groq API.
    Returns the generated remark string.
    """
    try:
        prompt = f"""
Generate a concise and summarized remark (in 50 words or less) for the following student's term record:
{student_record}
Ensure the remark is encouraging and constructive.
"""
        response = groq_client.chat.completions.create(
            model="mixtral-8x7b-32768",
            messages=[
                {"role": "system", "content": "You are an academic evaluator providing concise term summaries."},
                {"role": "user", "content": prompt}
            ]
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        print(f"Error generating summary: {str(e)}")
        return f"Error generating remark: {str(e)}"

def filter_students(df: pd.DataFrame, student_ids: List[str] = None) -> pd.DataFrame:
    """
    Filter the DataFrame based on a list of student IDs.
    """
    filtered_df = df.copy()
    if student_ids:
        filtered_df["ID"] = filtered_df["ID"].astype(str)
        student_ids = [str(s).strip() for s in student_ids]
        filtered_df = filtered_df[filtered_df["ID"].isin(student_ids)]
    return filtered_df

# =======================
# Customized PDF Report Generation
# =======================
class ReportCardPDF(FPDF):
    """Custom PDF generator that uses user-specified customizations."""
    def __init__(self, custom_header=None, custom_footer=None, logo_path=None, theme_color=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.custom_header = custom_header if custom_header else DEFAULT_HEADER
        self.custom_footer = custom_footer if custom_footer else DEFAULT_FOOTER
        self.logo_path = logo_path
        self.theme_color = theme_color if theme_color else DEFAULT_THEME_COLOR

    def header(self):
        # Add logo if available (with a smaller width)
        if self.logo_path:
            try:
                self.image(self.logo_path, 10, 8, 20)  # width set to 20 for a smaller logo
            except Exception as e:
                print("Logo error:", e)
        self.set_font("Arial", "B", 14)
        self.set_text_color(*hex_to_rgb(self.theme_color))
        self.cell(0, 10, self.custom_header, 0, 1, "C")
        self.ln(10)

    def footer(self):
        self.set_y(-15)
        self.set_font("Arial", "I", 8)
        self.set_text_color(128, 128, 128)
        self.cell(0, 10, self.custom_footer, 0, 0, "C")

def generate_report_card(student: pd.Series, subjects: List[str], output_folder: str,
                         custom_header=None, custom_footer=None, logo_path=None, theme_color=None) -> str:
    """Generate a PDF report card for a student using customization options."""
    pdf = ReportCardPDF(custom_header, custom_footer, logo_path, theme_color)
    pdf.add_page()
    
    # Student Information
    pdf.set_font("Arial", size=12)
    pdf.cell(40, 8, f"Name: {student['Name']}")
    pdf.cell(40, 8, f"ID: {student['ID']}", ln=1)
    pdf.ln(10)
    
    # Grades Table
    pdf.set_font("Arial", "B", 10)
    headers = ["Subject", "FA1", "FA2", "Exam", "Total", "Grade", "Rank"]
    col_widths = [40, 20, 20, 20, 20, 20, 20]
    for header, width in zip(headers, col_widths):
        pdf.cell(width, 8, header, 1)
    pdf.ln()
    
    pdf.set_font("Arial", size=10)
    for subject in subjects:
        if all(f"{subject} {assess}" in student for assess in ["FA1", "FA2", "Exam"]):
            data = [
                subject,
                student[f"{subject} FA1"],
                student[f"{subject} FA2"],
                student[f"{subject} Exam"],
                student[f"{subject} Total"],
                student[f"{subject} Grade"],
                student[f"{subject} Position"]
            ]
            for value, width in zip(data, col_widths):
                pdf.cell(width, 8, str(value), 1)
            pdf.ln()
    
    # Overall Performance Section
    pdf.ln(10)
    pdf.set_font("Arial", "B", 12)
    pdf.cell(0, 10, "Overall Performance:")
    pdf.ln(8)
    pdf.set_font("Arial", size=10)
    overall_total = student.get("Overall Total", "N/A")
    overall_average = student.get("Overall Average", "N/A")
    overall_rank = student.get("Rank", "N/A")
    pdf.cell(0, 6, f"Overall Total: {overall_total}")
    pdf.ln(6)
    pdf.cell(0, 6, f"Overall Average: {overall_average}")
    pdf.ln(6)
    pdf.cell(0, 6, f"Overall Rank: {overall_rank}")
    pdf.ln(10)

    # AI-Powered Summary
    try:
        ai_summary = generate_summary(student.to_dict())
        pdf.ln(10)
        pdf.set_font("Arial", "B", 12)
        pdf.cell(40, 10, "Performance Summary:")
        pdf.ln(8)
        pdf.set_font("Arial", size=10)
        pdf.multi_cell(0, 6, ai_summary)
    except Exception as e:
        pdf.multi_cell(0, 6, f"Summary unavailable: {str(e)}")
    
    # Save with sanitized filename
    sanitized_name = student['Name'].replace(" ", "_").replace("/", "-")[:100]
    output_path = os.path.join(output_folder, f"Report_{sanitized_name}_{student['ID']}.pdf")
    pdf.output(output_path)
    return output_path

# =======================
# Chart Functions & Download Helper
# =======================
def download_chart(fig):
    """Prompt the user to save the given matplotlib figure as a PNG file."""
    file_path = filedialog.asksaveasfilename(defaultextension=".png", filetypes=[("PNG Files", "*.png")])
    if file_path:
        fig.savefig(file_path)
        messagebox.showinfo("Download", f"Chart saved to {file_path}")

def show_top_bottom_students(df: pd.DataFrame):
    """Display a chart of the top 5 and bottom 5 students based on Overall Total."""
    if "Overall Total" not in df.columns:
        messagebox.showerror("Error", "Data does not include Overall Total scores.")
        return

    df_sorted = df.sort_values(by="Overall Total", ascending=False)
    top_students = df_sorted.head(5)
    bottom_students = df_sorted.tail(5)
    
    fig, axs = plt.subplots(1, 2, figsize=(12, 6))
    axs[0].bar(top_students["Name"], top_students["Overall Total"], color='green')
    axs[0].set_title("Top 5 Students")
    axs[0].set_xlabel("Student Name")
    axs[0].set_ylabel("Overall Total")
    axs[0].tick_params(axis='x', rotation=45)
    
    axs[1].bar(bottom_students["Name"], bottom_students["Overall Total"], color='red')
    axs[1].set_title("Bottom 5 Students (Need Help)")
    axs[1].set_xlabel("Student Name")
    axs[1].set_ylabel("Overall Total")
    axs[1].tick_params(axis='x', rotation=45)
    
    plt.tight_layout()
    
    chart_window = Toplevel()
    chart_window.title("Top and Bottom Students")
    canvas = FigureCanvasTkAgg(fig, master=chart_window)
    canvas.draw()
    canvas.get_tk_widget().pack()
    
    btn_download = Button(chart_window, text="Download Chart", command=lambda: download_chart(fig), font=("Arial", 12))
    btn_download.pack(pady=10)

def show_subject_trends(df: pd.DataFrame, subjects: List[str]):
    """Display a grouped bar chart showing average scores for FA1, FA2, and Exam for each subject."""
    averages = {}
    for subject in subjects:
        fa1_col = f"{subject} FA1"
        fa2_col = f"{subject} FA2"
        exam_col = f"{subject} Exam"
        if fa1_col in df.columns and fa2_col in df.columns and exam_col in df.columns:
            averages[subject] = {
                "FA1": df[fa1_col].mean(),
                "FA2": df[fa2_col].mean(),
                "Exam": df[exam_col].mean()
            }
    
    subjects_list = list(averages.keys())
    if not subjects_list:
        messagebox.showerror("Error", "No subject data available for trends.")
        return

    fa1_means = [averages[subj]["FA1"] for subj in subjects_list]
    fa2_means = [averages[subj]["FA2"] for subj in subjects_list]
    exam_means = [averages[subj]["Exam"] for subj in subjects_list]
    
    x = range(len(subjects_list))
    width = 0.25
    
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.bar([p - width for p in x], fa1_means, width, label="FA1")
    ax.bar(x, fa2_means, width, label="FA2")
    ax.bar([p + width for p in x], exam_means, width, label="Exam")
    
    ax.set_xlabel("Subject")
    ax.set_ylabel("Average Score")
    ax.set_title("Average Scores per Subject")
    ax.set_xticks(x)
    ax.set_xticklabels(subjects_list)
    ax.legend()
    
    plt.tight_layout()
    
    chart_window = Toplevel()
    chart_window.title("Subject Trends")
    canvas = FigureCanvasTkAgg(fig, master=chart_window)
    canvas.draw()
    canvas.get_tk_widget().pack()
    
    btn_download = Button(chart_window, text="Download Chart", command=lambda: download_chart(fig), font=("Arial", 12))
    btn_download.pack(pady=10)

# =======================
# Function to Open Folder
# =======================
def open_folder(folder_path):
    """Open the given folder in the system's file explorer."""
    try:
        if platform.system() == "Windows":
            os.startfile(folder_path)
        elif platform.system() == "Darwin":  # macOS
            subprocess.Popen(["open", folder_path])
        else:  # Linux variants
            subprocess.Popen(["xdg-open", folder_path])
    except Exception as e:
        messagebox.showerror("Error", f"Could not open folder: {str(e)}")

# =======================
# Main Application Class
# =======================
class ReportGeneratorApp:
    def __init__(self, root: Tk):
        self.root = root
        # Default customization settings
        self.custom_header = DEFAULT_HEADER
        self.custom_footer = DEFAULT_FOOTER
        self.logo_path = None
        self.theme_color = DEFAULT_THEME_COLOR
        
        self.df = None       
        self.subjects = []    
        self.teacher_name = ""  
        self.teacher_folder = None  
        
        self.setup_ui()
    
    def setup_ui(self):
        """Configure the main user interface."""
        self.root.title("Academic Report Generator Pro")
        self.root.geometry("600x650")
        
        Label(self.root, text="Academic Report Generator", font=("Arial", 18)).pack(pady=10)
        
        # Teacher Name Entry
        Label(self.root, text="Enter Teacher Name:", font=("Arial", 12)).pack(pady=5)
        self.teacher_entry = Entry(self.root, font=("Arial", 12), width=30)
        self.teacher_entry.pack(pady=5)
        
        # Settings button for customization options
        self.btn_settings = Button(self.root, text="Settings", command=self.open_settings, font=("Arial", 12), width=25)
        self.btn_settings.pack(pady=5)
        
        self.btn_process = Button(
            self.root, text="Select Excel File", command=self.process_files,
            font=("Arial", 12), width=25
        )
        self.btn_process.pack(pady=10)
        
        self.progress_label = Label(self.root, text="Status: Ready", font=("Arial", 10))
        self.progress_label.pack(pady=5)
        
        self.progress_bar = ttk.Progressbar(self.root, length=400, mode="determinate")
        self.progress_bar.pack(pady=10)
        
        # Chart Buttons (disabled until data is processed)
        self.btn_top_bottom = Button(
            self.root, text="Show Top/Bottom Students Chart", 
            command=lambda: show_top_bottom_students(self.df),
            font=("Arial", 12), width=30, state="disabled"
        )
        self.btn_top_bottom.pack(pady=5)
        
        self.btn_subject_trends = Button(
            self.root, text="Show Subject Trends Chart", 
            command=lambda: show_subject_trends(self.df, self.subjects),
            font=("Arial", 12), width=30, state="disabled"
        )
        self.btn_subject_trends.pack(pady=5)
        
        # Button to Open Teacher Folder (disabled until folder is created)
        self.btn_open_folder = Button(
            self.root, text="Open Teacher Folder", 
            command=lambda: open_folder(self.teacher_folder),
            font=("Arial", 12), width=30, state="disabled"
        )
        self.btn_open_folder.pack(pady=5)
        
        Button(self.root, text="Exit", command=self.root.destroy, font=("Arial", 10)).pack(pady=10)
    
    def open_settings(self):
        """Open a settings window for customization options."""
        settings_win = Toplevel(self.root)
        settings_win.title("Customization Settings")
        settings_win.geometry("400x350")
        
        Label(settings_win, text="Header Text:", font=("Arial", 12)).pack(pady=5)
        header_entry = Entry(settings_win, font=("Arial", 12))
        header_entry.insert(0, self.custom_header)
        header_entry.pack(pady=5)
        
        Label(settings_win, text="Footer Text:", font=("Arial", 12)).pack(pady=5)
        footer_entry = Entry(settings_win, font=("Arial", 12))
        footer_entry.insert(0, self.custom_footer)
        footer_entry.pack(pady=5)
        
        def choose_logo():
            logo = filedialog.askopenfilename(filetypes=[("Image Files", "*.png;*.jpg;*.jpeg")])
            if logo:
                self.logo_path = logo
                logo_label.config(text=os.path.basename(logo))
        Button(settings_win, text="Choose Logo", command=choose_logo, font=("Arial", 12)).pack(pady=5)
        logo_label = Label(settings_win, text="No logo selected", font=("Arial", 10))
        logo_label.pack(pady=5)
        
        def choose_color():
            color = colorchooser.askcolor()[1]
            if color:
                self.theme_color = color
                color_label.config(text=color, bg=color)
        Button(settings_win, text="Choose Theme Color", command=choose_color, font=("Arial", 12)).pack(pady=5)
        color_label = Label(settings_win, text=self.theme_color, font=("Arial", 10), bg=self.theme_color)
        color_label.pack(pady=5)
        
        def save_settings():
            self.custom_header = header_entry.get()
            self.custom_footer = footer_entry.get()
            messagebox.showinfo("Settings", "Customization settings saved!")
            settings_win.destroy()
        Button(settings_win, text="Save Settings", command=save_settings, font=("Arial", 12)).pack(pady=10)
    
    def process_files(self):
        """Handle the file processing workflow."""
        self.teacher_name = self.teacher_entry.get().strip()
        if not self.teacher_name:
            messagebox.showerror("Error", "Teacher name is required!")
            return
        
        file_path = filedialog.askopenfilename(filetypes=[("Excel Files", "*.xlsx")])
        if not file_path:
            return
        
        output_folder = filedialog.askdirectory(title="Select Output Folder")
        if not output_folder:
            return
        
        # Create a folder for the teacher
        self.teacher_folder = os.path.join(output_folder, self.teacher_name)
        os.makedirs(self.teacher_folder, exist_ok=True)
        
        try:
            df = pd.read_excel(file_path)
            if "ID" in df.columns:
                df["ID"] = df["ID"].astype(str)
            if not validate_dataframe(df):
                messagebox.showerror("Error", "Invalid file format")
                return
            
            subjects = self.process_subjects(df)
            
            # Optionally filter by student IDs
            if messagebox.askyesno("Filter Students", "Do you want to filter the students by ID before generating reports?"):
                student_ids_str = simpledialog.askstring("Filter by IDs", "Enter Student IDs (comma separated):")
                student_ids = [s.strip() for s in student_ids_str.split(",")] if student_ids_str else None
                df = filter_students(df, student_ids=student_ids)
            
            self.df = df
            self.subjects = subjects
            
            self.generate_reports(df, subjects, self.teacher_folder)
            messagebox.showinfo("Success", f"Generated {len(df)} report cards in folder:\n{self.teacher_folder}")
            self.btn_top_bottom.config(state="normal")
            self.btn_subject_trends.config(state="normal")
            self.btn_open_folder.config(state="normal")  
        except Exception as e:
            messagebox.showerror("Error", f"Processing failed: {str(e)}")
    
    def process_subjects(self, df: pd.DataFrame) -> List[str]:
        """Process subjects and compute totals, grades, and positions."""
        subjects = []
        for col in df.columns:
            if "FA1" in col:
                subject = col.split()[0]
                if all(f"{subject} {assess}" in df.columns for assess in ["FA2", "Exam"]):
                    df[f"{subject} Total"] = df[[f"{subject} FA1", f"{subject} FA2", f"{subject} Exam"]].sum(axis=1)
                    df[f"{subject} Grade"] = df[f"{subject} Total"].apply(calculate_grade)
                    df[f"{subject} Position"] = df[f"{subject} Total"].rank(ascending=False, method="min").astype(int)
                    subjects.append(subject)
        
        if subjects:
            df["Overall Total"] = df[[f"{s} Total" for s in subjects]].sum(axis=1)
            df["Overall Average"] = df["Overall Total"] / len(subjects)
            df["Rank"] = df["Overall Total"].rank(ascending=False, method="min").astype(int)
            df["Overall Grade"] = df["Overall Total"].apply(calculate_grade)
        
        return subjects
    
    def generate_reports(self, df: pd.DataFrame, subjects: List[str], output_folder: str):
        """Generate PDF report cards for each student, using customization settings."""
        total_students = len(df)
        for idx, (_, row) in enumerate(df.iterrows(), start=1):
            try:
                generate_report_card(
                    row, subjects, output_folder,
                    custom_header=self.custom_header,
                    custom_footer=self.custom_footer,
                    logo_path=self.logo_path,
                    theme_color=self.theme_color
                )
                progress = (idx / total_students) * 100
                self.progress_bar["value"] = progress
                self.progress_label.config(text=f"Processing: {idx}/{total_students}")
                self.root.update_idletasks()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to process {row['Name']}: {str(e)}")

# =======================
# Application Entry Point
# =======================
if __name__ == "__main__":
    import platform  
    import subprocess
    root = Tk()
    app = ReportGeneratorApp(root)
    root.mainloop()
